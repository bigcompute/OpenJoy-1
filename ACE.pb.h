// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ACE.proto

#ifndef PROTOBUF_ACE_2eproto__INCLUDED
#define PROTOBUF_ACE_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace ace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ACE_2eproto();
void protobuf_AssignDesc_ACE_2eproto();
void protobuf_ShutdownFile_ACE_2eproto();

class MainRxn;
class EnergyGridDataPoint;
class EnergyGrid;
class Xsec;
class Reaction;
class NeutronData;

// ===================================================================

class MainRxn : public ::google::protobuf::Message {
 public:
  MainRxn();
  virtual ~MainRxn();

  MainRxn(const MainRxn& from);

  inline MainRxn& operator=(const MainRxn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MainRxn& default_instance();

  void Swap(MainRxn* other);

  // implements Message ----------------------------------------------

  MainRxn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MainRxn& from);
  void MergeFrom(const MainRxn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline double total() const;
  inline void set_total(double value);

  // required double elastic = 2;
  inline bool has_elastic() const;
  inline void clear_elastic();
  static const int kElasticFieldNumber = 2;
  inline double elastic() const;
  inline void set_elastic(double value);

  // required double absorption = 3;
  inline bool has_absorption() const;
  inline void clear_absorption();
  static const int kAbsorptionFieldNumber = 3;
  inline double absorption() const;
  inline void set_absorption(double value);

  // required double fission = 4;
  inline bool has_fission() const;
  inline void clear_fission();
  static const int kFissionFieldNumber = 4;
  inline double fission() const;
  inline void set_fission(double value);

  // required double heating = 5;
  inline bool has_heating() const;
  inline void clear_heating();
  static const int kHeatingFieldNumber = 5;
  inline double heating() const;
  inline void set_heating(double value);

  // @@protoc_insertion_point(class_scope:proto.ace.MainRxn)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_elastic();
  inline void clear_has_elastic();
  inline void set_has_absorption();
  inline void clear_has_absorption();
  inline void set_has_fission();
  inline void clear_has_fission();
  inline void set_has_heating();
  inline void clear_has_heating();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double total_;
  double elastic_;
  double absorption_;
  double fission_;
  double heating_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static MainRxn* default_instance_;
};
// -------------------------------------------------------------------

class EnergyGridDataPoint : public ::google::protobuf::Message {
 public:
  EnergyGridDataPoint();
  virtual ~EnergyGridDataPoint();

  EnergyGridDataPoint(const EnergyGridDataPoint& from);

  inline EnergyGridDataPoint& operator=(const EnergyGridDataPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnergyGridDataPoint& default_instance();

  void Swap(EnergyGridDataPoint* other);

  // implements Message ----------------------------------------------

  EnergyGridDataPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnergyGridDataPoint& from);
  void MergeFrom(const EnergyGridDataPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required .proto.ace.MainRxn y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline const ::proto::ace::MainRxn& y() const;
  inline ::proto::ace::MainRxn* mutable_y();
  inline ::proto::ace::MainRxn* release_y();
  inline void set_allocated_y(::proto::ace::MainRxn* y);

  // @@protoc_insertion_point(class_scope:proto.ace.EnergyGridDataPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  ::proto::ace::MainRxn* y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static EnergyGridDataPoint* default_instance_;
};
// -------------------------------------------------------------------

class EnergyGrid : public ::google::protobuf::Message {
 public:
  EnergyGrid();
  virtual ~EnergyGrid();

  EnergyGrid(const EnergyGrid& from);

  inline EnergyGrid& operator=(const EnergyGrid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnergyGrid& default_instance();

  void Swap(EnergyGrid* other);

  // implements Message ----------------------------------------------

  EnergyGrid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnergyGrid& from);
  void MergeFrom(const EnergyGrid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.ace.EnergyGridDataPoint data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::proto::ace::EnergyGridDataPoint& data(int index) const;
  inline ::proto::ace::EnergyGridDataPoint* mutable_data(int index);
  inline ::proto::ace::EnergyGridDataPoint* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::ace::EnergyGridDataPoint >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::ace::EnergyGridDataPoint >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:proto.ace.EnergyGrid)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::ace::EnergyGridDataPoint > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static EnergyGrid* default_instance_;
};
// -------------------------------------------------------------------

class Xsec : public ::google::protobuf::Message {
 public:
  Xsec();
  virtual ~Xsec();

  Xsec(const Xsec& from);

  inline Xsec& operator=(const Xsec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Xsec& default_instance();

  void Swap(Xsec* other);

  // implements Message ----------------------------------------------

  Xsec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Xsec& from);
  void MergeFrom(const Xsec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::int64 start() const;
  inline void set_start(::google::protobuf::int64 value);

  // repeated double sigmas = 2;
  inline int sigmas_size() const;
  inline void clear_sigmas();
  static const int kSigmasFieldNumber = 2;
  inline double sigmas(int index) const;
  inline void set_sigmas(int index, double value);
  inline void add_sigmas(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      sigmas() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_sigmas();

  // @@protoc_insertion_point(class_scope:proto.ace.Xsec)
 private:
  inline void set_has_start();
  inline void clear_has_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 start_;
  ::google::protobuf::RepeatedField< double > sigmas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static Xsec* default_instance_;
};
// -------------------------------------------------------------------

class Reaction : public ::google::protobuf::Message {
 public:
  Reaction();
  virtual ~Reaction();

  Reaction(const Reaction& from);

  inline Reaction& operator=(const Reaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reaction& default_instance();

  void Swap(Reaction* other);

  // implements Message ----------------------------------------------

  Reaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reaction& from);
  void MergeFrom(const Reaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 MT = 1;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMTFieldNumber = 1;
  inline ::google::protobuf::int64 mt() const;
  inline void set_mt(::google::protobuf::int64 value);

  // required .proto.ace.Xsec xsec = 8;
  inline bool has_xsec() const;
  inline void clear_xsec();
  static const int kXsecFieldNumber = 8;
  inline const ::proto::ace::Xsec& xsec() const;
  inline ::proto::ace::Xsec* mutable_xsec();
  inline ::proto::ace::Xsec* release_xsec();
  inline void set_allocated_xsec(::proto::ace::Xsec* xsec);

  // @@protoc_insertion_point(class_scope:proto.ace.Reaction)
 private:
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_xsec();
  inline void clear_has_xsec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 mt_;
  ::proto::ace::Xsec* xsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static Reaction* default_instance_;
};
// -------------------------------------------------------------------

class NeutronData : public ::google::protobuf::Message {
 public:
  NeutronData();
  virtual ~NeutronData();

  NeutronData(const NeutronData& from);

  inline NeutronData& operator=(const NeutronData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NeutronData& default_instance();

  void Swap(NeutronData* other);

  // implements Message ----------------------------------------------

  NeutronData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NeutronData& from);
  void MergeFrom(const NeutronData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 ZA = 1;
  inline bool has_za() const;
  inline void clear_za();
  static const int kZAFieldNumber = 1;
  inline ::google::protobuf::int64 za() const;
  inline void set_za(::google::protobuf::int64 value);

  // required double AWR = 2;
  inline bool has_awr() const;
  inline void clear_awr();
  static const int kAWRFieldNumber = 2;
  inline double awr() const;
  inline void set_awr(double value);

  // required double TEMPK = 3;
  inline bool has_tempk() const;
  inline void clear_tempk();
  static const int kTEMPKFieldNumber = 3;
  inline double tempk() const;
  inline void set_tempk(double value);

  // required .proto.ace.EnergyGrid energyMevGrid = 4;
  inline bool has_energymevgrid() const;
  inline void clear_energymevgrid();
  static const int kEnergyMevGridFieldNumber = 4;
  inline const ::proto::ace::EnergyGrid& energymevgrid() const;
  inline ::proto::ace::EnergyGrid* mutable_energymevgrid();
  inline ::proto::ace::EnergyGrid* release_energymevgrid();
  inline void set_allocated_energymevgrid(::proto::ace::EnergyGrid* energymevgrid);

  // repeated .proto.ace.Reaction reactions = 5;
  inline int reactions_size() const;
  inline void clear_reactions();
  static const int kReactionsFieldNumber = 5;
  inline const ::proto::ace::Reaction& reactions(int index) const;
  inline ::proto::ace::Reaction* mutable_reactions(int index);
  inline ::proto::ace::Reaction* add_reactions();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::ace::Reaction >&
      reactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::ace::Reaction >*
      mutable_reactions();

  // @@protoc_insertion_point(class_scope:proto.ace.NeutronData)
 private:
  inline void set_has_za();
  inline void clear_has_za();
  inline void set_has_awr();
  inline void clear_has_awr();
  inline void set_has_tempk();
  inline void clear_has_tempk();
  inline void set_has_energymevgrid();
  inline void clear_has_energymevgrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 za_;
  double awr_;
  double tempk_;
  ::proto::ace::EnergyGrid* energymevgrid_;
  ::google::protobuf::RepeatedPtrField< ::proto::ace::Reaction > reactions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ACE_2eproto();
  friend void protobuf_AssignDesc_ACE_2eproto();
  friend void protobuf_ShutdownFile_ACE_2eproto();

  void InitAsDefaultInstance();
  static NeutronData* default_instance_;
};
// ===================================================================


// ===================================================================

// MainRxn

// required double total = 1;
inline bool MainRxn::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MainRxn::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MainRxn::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MainRxn::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline double MainRxn::total() const {
  return total_;
}
inline void MainRxn::set_total(double value) {
  set_has_total();
  total_ = value;
}

// required double elastic = 2;
inline bool MainRxn::has_elastic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MainRxn::set_has_elastic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MainRxn::clear_has_elastic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MainRxn::clear_elastic() {
  elastic_ = 0;
  clear_has_elastic();
}
inline double MainRxn::elastic() const {
  return elastic_;
}
inline void MainRxn::set_elastic(double value) {
  set_has_elastic();
  elastic_ = value;
}

// required double absorption = 3;
inline bool MainRxn::has_absorption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MainRxn::set_has_absorption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MainRxn::clear_has_absorption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MainRxn::clear_absorption() {
  absorption_ = 0;
  clear_has_absorption();
}
inline double MainRxn::absorption() const {
  return absorption_;
}
inline void MainRxn::set_absorption(double value) {
  set_has_absorption();
  absorption_ = value;
}

// required double fission = 4;
inline bool MainRxn::has_fission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MainRxn::set_has_fission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MainRxn::clear_has_fission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MainRxn::clear_fission() {
  fission_ = 0;
  clear_has_fission();
}
inline double MainRxn::fission() const {
  return fission_;
}
inline void MainRxn::set_fission(double value) {
  set_has_fission();
  fission_ = value;
}

// required double heating = 5;
inline bool MainRxn::has_heating() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MainRxn::set_has_heating() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MainRxn::clear_has_heating() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MainRxn::clear_heating() {
  heating_ = 0;
  clear_has_heating();
}
inline double MainRxn::heating() const {
  return heating_;
}
inline void MainRxn::set_heating(double value) {
  set_has_heating();
  heating_ = value;
}

// -------------------------------------------------------------------

// EnergyGridDataPoint

// required double x = 1;
inline bool EnergyGridDataPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnergyGridDataPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnergyGridDataPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnergyGridDataPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double EnergyGridDataPoint::x() const {
  return x_;
}
inline void EnergyGridDataPoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required .proto.ace.MainRxn y = 2;
inline bool EnergyGridDataPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnergyGridDataPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnergyGridDataPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnergyGridDataPoint::clear_y() {
  if (y_ != NULL) y_->::proto::ace::MainRxn::Clear();
  clear_has_y();
}
inline const ::proto::ace::MainRxn& EnergyGridDataPoint::y() const {
  return y_ != NULL ? *y_ : *default_instance_->y_;
}
inline ::proto::ace::MainRxn* EnergyGridDataPoint::mutable_y() {
  set_has_y();
  if (y_ == NULL) y_ = new ::proto::ace::MainRxn;
  return y_;
}
inline ::proto::ace::MainRxn* EnergyGridDataPoint::release_y() {
  clear_has_y();
  ::proto::ace::MainRxn* temp = y_;
  y_ = NULL;
  return temp;
}
inline void EnergyGridDataPoint::set_allocated_y(::proto::ace::MainRxn* y) {
  delete y_;
  y_ = y;
  if (y) {
    set_has_y();
  } else {
    clear_has_y();
  }
}

// -------------------------------------------------------------------

// EnergyGrid

// repeated .proto.ace.EnergyGridDataPoint data = 1;
inline int EnergyGrid::data_size() const {
  return data_.size();
}
inline void EnergyGrid::clear_data() {
  data_.Clear();
}
inline const ::proto::ace::EnergyGridDataPoint& EnergyGrid::data(int index) const {
  return data_.Get(index);
}
inline ::proto::ace::EnergyGridDataPoint* EnergyGrid::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::proto::ace::EnergyGridDataPoint* EnergyGrid::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ace::EnergyGridDataPoint >&
EnergyGrid::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ace::EnergyGridDataPoint >*
EnergyGrid::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Xsec

// required int64 start = 1;
inline bool Xsec::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Xsec::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Xsec::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Xsec::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 Xsec::start() const {
  return start_;
}
inline void Xsec::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
}

// repeated double sigmas = 2;
inline int Xsec::sigmas_size() const {
  return sigmas_.size();
}
inline void Xsec::clear_sigmas() {
  sigmas_.Clear();
}
inline double Xsec::sigmas(int index) const {
  return sigmas_.Get(index);
}
inline void Xsec::set_sigmas(int index, double value) {
  sigmas_.Set(index, value);
}
inline void Xsec::add_sigmas(double value) {
  sigmas_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Xsec::sigmas() const {
  return sigmas_;
}
inline ::google::protobuf::RepeatedField< double >*
Xsec::mutable_sigmas() {
  return &sigmas_;
}

// -------------------------------------------------------------------

// Reaction

// required int64 MT = 1;
inline bool Reaction::has_mt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reaction::set_has_mt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reaction::clear_has_mt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reaction::clear_mt() {
  mt_ = GOOGLE_LONGLONG(0);
  clear_has_mt();
}
inline ::google::protobuf::int64 Reaction::mt() const {
  return mt_;
}
inline void Reaction::set_mt(::google::protobuf::int64 value) {
  set_has_mt();
  mt_ = value;
}

// required .proto.ace.Xsec xsec = 8;
inline bool Reaction::has_xsec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reaction::set_has_xsec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reaction::clear_has_xsec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reaction::clear_xsec() {
  if (xsec_ != NULL) xsec_->::proto::ace::Xsec::Clear();
  clear_has_xsec();
}
inline const ::proto::ace::Xsec& Reaction::xsec() const {
  return xsec_ != NULL ? *xsec_ : *default_instance_->xsec_;
}
inline ::proto::ace::Xsec* Reaction::mutable_xsec() {
  set_has_xsec();
  if (xsec_ == NULL) xsec_ = new ::proto::ace::Xsec;
  return xsec_;
}
inline ::proto::ace::Xsec* Reaction::release_xsec() {
  clear_has_xsec();
  ::proto::ace::Xsec* temp = xsec_;
  xsec_ = NULL;
  return temp;
}
inline void Reaction::set_allocated_xsec(::proto::ace::Xsec* xsec) {
  delete xsec_;
  xsec_ = xsec;
  if (xsec) {
    set_has_xsec();
  } else {
    clear_has_xsec();
  }
}

// -------------------------------------------------------------------

// NeutronData

// required int64 ZA = 1;
inline bool NeutronData::has_za() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NeutronData::set_has_za() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NeutronData::clear_has_za() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NeutronData::clear_za() {
  za_ = GOOGLE_LONGLONG(0);
  clear_has_za();
}
inline ::google::protobuf::int64 NeutronData::za() const {
  return za_;
}
inline void NeutronData::set_za(::google::protobuf::int64 value) {
  set_has_za();
  za_ = value;
}

// required double AWR = 2;
inline bool NeutronData::has_awr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NeutronData::set_has_awr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NeutronData::clear_has_awr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NeutronData::clear_awr() {
  awr_ = 0;
  clear_has_awr();
}
inline double NeutronData::awr() const {
  return awr_;
}
inline void NeutronData::set_awr(double value) {
  set_has_awr();
  awr_ = value;
}

// required double TEMPK = 3;
inline bool NeutronData::has_tempk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NeutronData::set_has_tempk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NeutronData::clear_has_tempk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NeutronData::clear_tempk() {
  tempk_ = 0;
  clear_has_tempk();
}
inline double NeutronData::tempk() const {
  return tempk_;
}
inline void NeutronData::set_tempk(double value) {
  set_has_tempk();
  tempk_ = value;
}

// required .proto.ace.EnergyGrid energyMevGrid = 4;
inline bool NeutronData::has_energymevgrid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NeutronData::set_has_energymevgrid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NeutronData::clear_has_energymevgrid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NeutronData::clear_energymevgrid() {
  if (energymevgrid_ != NULL) energymevgrid_->::proto::ace::EnergyGrid::Clear();
  clear_has_energymevgrid();
}
inline const ::proto::ace::EnergyGrid& NeutronData::energymevgrid() const {
  return energymevgrid_ != NULL ? *energymevgrid_ : *default_instance_->energymevgrid_;
}
inline ::proto::ace::EnergyGrid* NeutronData::mutable_energymevgrid() {
  set_has_energymevgrid();
  if (energymevgrid_ == NULL) energymevgrid_ = new ::proto::ace::EnergyGrid;
  return energymevgrid_;
}
inline ::proto::ace::EnergyGrid* NeutronData::release_energymevgrid() {
  clear_has_energymevgrid();
  ::proto::ace::EnergyGrid* temp = energymevgrid_;
  energymevgrid_ = NULL;
  return temp;
}
inline void NeutronData::set_allocated_energymevgrid(::proto::ace::EnergyGrid* energymevgrid) {
  delete energymevgrid_;
  energymevgrid_ = energymevgrid;
  if (energymevgrid) {
    set_has_energymevgrid();
  } else {
    clear_has_energymevgrid();
  }
}

// repeated .proto.ace.Reaction reactions = 5;
inline int NeutronData::reactions_size() const {
  return reactions_.size();
}
inline void NeutronData::clear_reactions() {
  reactions_.Clear();
}
inline const ::proto::ace::Reaction& NeutronData::reactions(int index) const {
  return reactions_.Get(index);
}
inline ::proto::ace::Reaction* NeutronData::mutable_reactions(int index) {
  return reactions_.Mutable(index);
}
inline ::proto::ace::Reaction* NeutronData::add_reactions() {
  return reactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ace::Reaction >&
NeutronData::reactions() const {
  return reactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ace::Reaction >*
NeutronData::mutable_reactions() {
  return &reactions_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ace
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ACE_2eproto__INCLUDED
