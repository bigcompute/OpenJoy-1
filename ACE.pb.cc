// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ACE.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ACE.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace ace {

namespace {

const ::google::protobuf::Descriptor* MainRxn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MainRxn_reflection_ = NULL;
const ::google::protobuf::Descriptor* EnergyGridDataPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EnergyGridDataPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* EnergyGrid_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EnergyGrid_reflection_ = NULL;
const ::google::protobuf::Descriptor* Xsec_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Xsec_reflection_ = NULL;
const ::google::protobuf::Descriptor* Reaction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Reaction_reflection_ = NULL;
const ::google::protobuf::Descriptor* NeutronData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NeutronData_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ACE_2eproto() {
  protobuf_AddDesc_ACE_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ACE.proto");
  GOOGLE_CHECK(file != NULL);
  MainRxn_descriptor_ = file->message_type(0);
  static const int MainRxn_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, total_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, elastic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, absorption_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, fission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, heating_),
  };
  MainRxn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MainRxn_descriptor_,
      MainRxn::default_instance_,
      MainRxn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainRxn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MainRxn));
  EnergyGridDataPoint_descriptor_ = file->message_type(1);
  static const int EnergyGridDataPoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGridDataPoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGridDataPoint, y_),
  };
  EnergyGridDataPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EnergyGridDataPoint_descriptor_,
      EnergyGridDataPoint::default_instance_,
      EnergyGridDataPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGridDataPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGridDataPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EnergyGridDataPoint));
  EnergyGrid_descriptor_ = file->message_type(2);
  static const int EnergyGrid_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGrid, data_),
  };
  EnergyGrid_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EnergyGrid_descriptor_,
      EnergyGrid::default_instance_,
      EnergyGrid_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGrid, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnergyGrid, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EnergyGrid));
  Xsec_descriptor_ = file->message_type(3);
  static const int Xsec_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Xsec, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Xsec, sigmas_),
  };
  Xsec_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Xsec_descriptor_,
      Xsec::default_instance_,
      Xsec_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Xsec, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Xsec, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Xsec));
  Reaction_descriptor_ = file->message_type(4);
  static const int Reaction_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reaction, mt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reaction, xsec_),
  };
  Reaction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Reaction_descriptor_,
      Reaction::default_instance_,
      Reaction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reaction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reaction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Reaction));
  NeutronData_descriptor_ = file->message_type(5);
  static const int NeutronData_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, za_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, awr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, tempk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, energymevgrid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, reactions_),
  };
  NeutronData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NeutronData_descriptor_,
      NeutronData::default_instance_,
      NeutronData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NeutronData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NeutronData));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ACE_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MainRxn_descriptor_, &MainRxn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EnergyGridDataPoint_descriptor_, &EnergyGridDataPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EnergyGrid_descriptor_, &EnergyGrid::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Xsec_descriptor_, &Xsec::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Reaction_descriptor_, &Reaction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NeutronData_descriptor_, &NeutronData::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ACE_2eproto() {
  delete MainRxn::default_instance_;
  delete MainRxn_reflection_;
  delete EnergyGridDataPoint::default_instance_;
  delete EnergyGridDataPoint_reflection_;
  delete EnergyGrid::default_instance_;
  delete EnergyGrid_reflection_;
  delete Xsec::default_instance_;
  delete Xsec_reflection_;
  delete Reaction::default_instance_;
  delete Reaction_reflection_;
  delete NeutronData::default_instance_;
  delete NeutronData_reflection_;
}

void protobuf_AddDesc_ACE_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tACE.proto\022\tproto.ace\"_\n\007MainRxn\022\r\n\005tot"
    "al\030\001 \002(\001\022\017\n\007elastic\030\002 \002(\001\022\022\n\nabsorption\030"
    "\003 \002(\001\022\017\n\007fission\030\004 \002(\001\022\017\n\007heating\030\005 \002(\001\""
    "\?\n\023EnergyGridDataPoint\022\t\n\001x\030\001 \002(\001\022\035\n\001y\030\002"
    " \002(\0132\022.proto.ace.MainRxn\":\n\nEnergyGrid\022,"
    "\n\004data\030\001 \003(\0132\036.proto.ace.EnergyGridDataP"
    "oint\"%\n\004Xsec\022\r\n\005start\030\001 \002(\003\022\016\n\006sigmas\030\002 "
    "\003(\001\"5\n\010Reaction\022\n\n\002MT\030\001 \002(\003\022\035\n\004xsec\030\010 \002("
    "\0132\017.proto.ace.Xsec\"\213\001\n\013NeutronData\022\n\n\002ZA"
    "\030\001 \002(\003\022\013\n\003AWR\030\002 \002(\001\022\r\n\005TEMPK\030\003 \002(\001\022,\n\ren"
    "ergyMevGrid\030\004 \002(\0132\025.proto.ace.EnergyGrid"
    "\022&\n\treactions\030\005 \003(\0132\023.proto.ace.Reaction", 480);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ACE.proto", &protobuf_RegisterTypes);
  MainRxn::default_instance_ = new MainRxn();
  EnergyGridDataPoint::default_instance_ = new EnergyGridDataPoint();
  EnergyGrid::default_instance_ = new EnergyGrid();
  Xsec::default_instance_ = new Xsec();
  Reaction::default_instance_ = new Reaction();
  NeutronData::default_instance_ = new NeutronData();
  MainRxn::default_instance_->InitAsDefaultInstance();
  EnergyGridDataPoint::default_instance_->InitAsDefaultInstance();
  EnergyGrid::default_instance_->InitAsDefaultInstance();
  Xsec::default_instance_->InitAsDefaultInstance();
  Reaction::default_instance_->InitAsDefaultInstance();
  NeutronData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ACE_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ACE_2eproto {
  StaticDescriptorInitializer_ACE_2eproto() {
    protobuf_AddDesc_ACE_2eproto();
  }
} static_descriptor_initializer_ACE_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MainRxn::kTotalFieldNumber;
const int MainRxn::kElasticFieldNumber;
const int MainRxn::kAbsorptionFieldNumber;
const int MainRxn::kFissionFieldNumber;
const int MainRxn::kHeatingFieldNumber;
#endif  // !_MSC_VER

MainRxn::MainRxn()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MainRxn::InitAsDefaultInstance() {
}

MainRxn::MainRxn(const MainRxn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MainRxn::SharedCtor() {
  _cached_size_ = 0;
  total_ = 0;
  elastic_ = 0;
  absorption_ = 0;
  fission_ = 0;
  heating_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MainRxn::~MainRxn() {
  SharedDtor();
}

void MainRxn::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MainRxn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MainRxn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MainRxn_descriptor_;
}

const MainRxn& MainRxn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

MainRxn* MainRxn::default_instance_ = NULL;

MainRxn* MainRxn::New() const {
  return new MainRxn;
}

void MainRxn::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    total_ = 0;
    elastic_ = 0;
    absorption_ = 0;
    fission_ = 0;
    heating_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MainRxn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double total = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &total_)));
          set_has_total();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_elastic;
        break;
      }

      // required double elastic = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_elastic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &elastic_)));
          set_has_elastic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_absorption;
        break;
      }

      // required double absorption = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_absorption:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &absorption_)));
          set_has_absorption();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_fission;
        break;
      }

      // required double fission = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_fission:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fission_)));
          set_has_fission();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_heating;
        break;
      }

      // required double heating = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_heating:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heating_)));
          set_has_heating();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MainRxn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double total = 1;
  if (has_total()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->total(), output);
  }

  // required double elastic = 2;
  if (has_elastic()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->elastic(), output);
  }

  // required double absorption = 3;
  if (has_absorption()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->absorption(), output);
  }

  // required double fission = 4;
  if (has_fission()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->fission(), output);
  }

  // required double heating = 5;
  if (has_heating()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->heating(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MainRxn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double total = 1;
  if (has_total()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->total(), target);
  }

  // required double elastic = 2;
  if (has_elastic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->elastic(), target);
  }

  // required double absorption = 3;
  if (has_absorption()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->absorption(), target);
  }

  // required double fission = 4;
  if (has_fission()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->fission(), target);
  }

  // required double heating = 5;
  if (has_heating()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->heating(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MainRxn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double total = 1;
    if (has_total()) {
      total_size += 1 + 8;
    }

    // required double elastic = 2;
    if (has_elastic()) {
      total_size += 1 + 8;
    }

    // required double absorption = 3;
    if (has_absorption()) {
      total_size += 1 + 8;
    }

    // required double fission = 4;
    if (has_fission()) {
      total_size += 1 + 8;
    }

    // required double heating = 5;
    if (has_heating()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MainRxn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MainRxn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MainRxn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MainRxn::MergeFrom(const MainRxn& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_total()) {
      set_total(from.total());
    }
    if (from.has_elastic()) {
      set_elastic(from.elastic());
    }
    if (from.has_absorption()) {
      set_absorption(from.absorption());
    }
    if (from.has_fission()) {
      set_fission(from.fission());
    }
    if (from.has_heating()) {
      set_heating(from.heating());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MainRxn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MainRxn::CopyFrom(const MainRxn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MainRxn::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void MainRxn::Swap(MainRxn* other) {
  if (other != this) {
    std::swap(total_, other->total_);
    std::swap(elastic_, other->elastic_);
    std::swap(absorption_, other->absorption_);
    std::swap(fission_, other->fission_);
    std::swap(heating_, other->heating_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MainRxn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MainRxn_descriptor_;
  metadata.reflection = MainRxn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EnergyGridDataPoint::kXFieldNumber;
const int EnergyGridDataPoint::kYFieldNumber;
#endif  // !_MSC_VER

EnergyGridDataPoint::EnergyGridDataPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EnergyGridDataPoint::InitAsDefaultInstance() {
  y_ = const_cast< ::proto::ace::MainRxn*>(&::proto::ace::MainRxn::default_instance());
}

EnergyGridDataPoint::EnergyGridDataPoint(const EnergyGridDataPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EnergyGridDataPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnergyGridDataPoint::~EnergyGridDataPoint() {
  SharedDtor();
}

void EnergyGridDataPoint::SharedDtor() {
  if (this != default_instance_) {
    delete y_;
  }
}

void EnergyGridDataPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EnergyGridDataPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EnergyGridDataPoint_descriptor_;
}

const EnergyGridDataPoint& EnergyGridDataPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

EnergyGridDataPoint* EnergyGridDataPoint::default_instance_ = NULL;

EnergyGridDataPoint* EnergyGridDataPoint::New() const {
  return new EnergyGridDataPoint;
}

void EnergyGridDataPoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    if (has_y()) {
      if (y_ != NULL) y_->::proto::ace::MainRxn::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EnergyGridDataPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_y;
        break;
      }

      // required .proto.ace.MainRxn y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_y:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_y()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnergyGridDataPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required .proto.ace.MainRxn y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EnergyGridDataPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required .proto.ace.MainRxn y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EnergyGridDataPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // required .proto.ace.MainRxn y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnergyGridDataPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EnergyGridDataPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EnergyGridDataPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EnergyGridDataPoint::MergeFrom(const EnergyGridDataPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      mutable_y()->::proto::ace::MainRxn::MergeFrom(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EnergyGridDataPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnergyGridDataPoint::CopyFrom(const EnergyGridDataPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnergyGridDataPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_y()) {
    if (!this->y().IsInitialized()) return false;
  }
  return true;
}

void EnergyGridDataPoint::Swap(EnergyGridDataPoint* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EnergyGridDataPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EnergyGridDataPoint_descriptor_;
  metadata.reflection = EnergyGridDataPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EnergyGrid::kDataFieldNumber;
#endif  // !_MSC_VER

EnergyGrid::EnergyGrid()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EnergyGrid::InitAsDefaultInstance() {
}

EnergyGrid::EnergyGrid(const EnergyGrid& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EnergyGrid::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnergyGrid::~EnergyGrid() {
  SharedDtor();
}

void EnergyGrid::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EnergyGrid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EnergyGrid::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EnergyGrid_descriptor_;
}

const EnergyGrid& EnergyGrid::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

EnergyGrid* EnergyGrid::default_instance_ = NULL;

EnergyGrid* EnergyGrid::New() const {
  return new EnergyGrid;
}

void EnergyGrid::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EnergyGrid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.ace.EnergyGridDataPoint data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnergyGrid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .proto.ace.EnergyGridDataPoint data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EnergyGrid::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .proto.ace.EnergyGridDataPoint data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EnergyGrid::ByteSize() const {
  int total_size = 0;

  // repeated .proto.ace.EnergyGridDataPoint data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnergyGrid::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EnergyGrid* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EnergyGrid*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EnergyGrid::MergeFrom(const EnergyGrid& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EnergyGrid::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnergyGrid::CopyFrom(const EnergyGrid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnergyGrid::IsInitialized() const {

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void EnergyGrid::Swap(EnergyGrid* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EnergyGrid::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EnergyGrid_descriptor_;
  metadata.reflection = EnergyGrid_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Xsec::kStartFieldNumber;
const int Xsec::kSigmasFieldNumber;
#endif  // !_MSC_VER

Xsec::Xsec()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Xsec::InitAsDefaultInstance() {
}

Xsec::Xsec(const Xsec& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Xsec::SharedCtor() {
  _cached_size_ = 0;
  start_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Xsec::~Xsec() {
  SharedDtor();
}

void Xsec::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Xsec::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Xsec::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Xsec_descriptor_;
}

const Xsec& Xsec::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

Xsec* Xsec::default_instance_ = NULL;

Xsec* Xsec::New() const {
  return new Xsec;
}

void Xsec::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_ = GOOGLE_LONGLONG(0);
  }
  sigmas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Xsec::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 start = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_sigmas;
        break;
      }

      // repeated double sigmas = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_sigmas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17, input, this->mutable_sigmas())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_sigmas())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_sigmas;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Xsec::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->start(), output);
  }

  // repeated double sigmas = 2;
  for (int i = 0; i < this->sigmas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      2, this->sigmas(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Xsec::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->start(), target);
  }

  // repeated double sigmas = 2;
  for (int i = 0; i < this->sigmas_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(2, this->sigmas(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Xsec::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->start());
    }

  }
  // repeated double sigmas = 2;
  {
    int data_size = 0;
    data_size = 8 * this->sigmas_size();
    total_size += 1 * this->sigmas_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Xsec::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Xsec* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Xsec*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Xsec::MergeFrom(const Xsec& from) {
  GOOGLE_CHECK_NE(&from, this);
  sigmas_.MergeFrom(from.sigmas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      set_start(from.start());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Xsec::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Xsec::CopyFrom(const Xsec& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Xsec::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Xsec::Swap(Xsec* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    sigmas_.Swap(&other->sigmas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Xsec::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Xsec_descriptor_;
  metadata.reflection = Xsec_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Reaction::kMTFieldNumber;
const int Reaction::kXsecFieldNumber;
#endif  // !_MSC_VER

Reaction::Reaction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Reaction::InitAsDefaultInstance() {
  xsec_ = const_cast< ::proto::ace::Xsec*>(&::proto::ace::Xsec::default_instance());
}

Reaction::Reaction(const Reaction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Reaction::SharedCtor() {
  _cached_size_ = 0;
  mt_ = GOOGLE_LONGLONG(0);
  xsec_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reaction::~Reaction() {
  SharedDtor();
}

void Reaction::SharedDtor() {
  if (this != default_instance_) {
    delete xsec_;
  }
}

void Reaction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Reaction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reaction_descriptor_;
}

const Reaction& Reaction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

Reaction* Reaction::default_instance_ = NULL;

Reaction* Reaction::New() const {
  return new Reaction;
}

void Reaction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mt_ = GOOGLE_LONGLONG(0);
    if (has_xsec()) {
      if (xsec_ != NULL) xsec_->::proto::ace::Xsec::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Reaction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 MT = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mt_)));
          set_has_mt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_xsec;
        break;
      }

      // required .proto.ace.Xsec xsec = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_xsec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xsec()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Reaction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 MT = 1;
  if (has_mt()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->mt(), output);
  }

  // required .proto.ace.Xsec xsec = 8;
  if (has_xsec()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->xsec(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Reaction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 MT = 1;
  if (has_mt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->mt(), target);
  }

  // required .proto.ace.Xsec xsec = 8;
  if (has_xsec()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->xsec(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Reaction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 MT = 1;
    if (has_mt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->mt());
    }

    // required .proto.ace.Xsec xsec = 8;
    if (has_xsec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->xsec());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reaction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Reaction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Reaction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Reaction::MergeFrom(const Reaction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mt()) {
      set_mt(from.mt());
    }
    if (from.has_xsec()) {
      mutable_xsec()->::proto::ace::Xsec::MergeFrom(from.xsec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Reaction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reaction::CopyFrom(const Reaction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reaction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_xsec()) {
    if (!this->xsec().IsInitialized()) return false;
  }
  return true;
}

void Reaction::Swap(Reaction* other) {
  if (other != this) {
    std::swap(mt_, other->mt_);
    std::swap(xsec_, other->xsec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Reaction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Reaction_descriptor_;
  metadata.reflection = Reaction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NeutronData::kZAFieldNumber;
const int NeutronData::kAWRFieldNumber;
const int NeutronData::kTEMPKFieldNumber;
const int NeutronData::kEnergyMevGridFieldNumber;
const int NeutronData::kReactionsFieldNumber;
#endif  // !_MSC_VER

NeutronData::NeutronData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NeutronData::InitAsDefaultInstance() {
  energymevgrid_ = const_cast< ::proto::ace::EnergyGrid*>(&::proto::ace::EnergyGrid::default_instance());
}

NeutronData::NeutronData(const NeutronData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NeutronData::SharedCtor() {
  _cached_size_ = 0;
  za_ = GOOGLE_LONGLONG(0);
  awr_ = 0;
  tempk_ = 0;
  energymevgrid_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NeutronData::~NeutronData() {
  SharedDtor();
}

void NeutronData::SharedDtor() {
  if (this != default_instance_) {
    delete energymevgrid_;
  }
}

void NeutronData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NeutronData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NeutronData_descriptor_;
}

const NeutronData& NeutronData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ACE_2eproto();
  return *default_instance_;
}

NeutronData* NeutronData::default_instance_ = NULL;

NeutronData* NeutronData::New() const {
  return new NeutronData;
}

void NeutronData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    za_ = GOOGLE_LONGLONG(0);
    awr_ = 0;
    tempk_ = 0;
    if (has_energymevgrid()) {
      if (energymevgrid_ != NULL) energymevgrid_->::proto::ace::EnergyGrid::Clear();
    }
  }
  reactions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NeutronData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 ZA = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &za_)));
          set_has_za();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_AWR;
        break;
      }

      // required double AWR = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_AWR:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &awr_)));
          set_has_awr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_TEMPK;
        break;
      }

      // required double TEMPK = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_TEMPK:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tempk_)));
          set_has_tempk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_energyMevGrid;
        break;
      }

      // required .proto.ace.EnergyGrid energyMevGrid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_energyMevGrid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_energymevgrid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reactions;
        break;
      }

      // repeated .proto.ace.Reaction reactions = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reactions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reactions;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NeutronData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 ZA = 1;
  if (has_za()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->za(), output);
  }

  // required double AWR = 2;
  if (has_awr()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->awr(), output);
  }

  // required double TEMPK = 3;
  if (has_tempk()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->tempk(), output);
  }

  // required .proto.ace.EnergyGrid energyMevGrid = 4;
  if (has_energymevgrid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->energymevgrid(), output);
  }

  // repeated .proto.ace.Reaction reactions = 5;
  for (int i = 0; i < this->reactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->reactions(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NeutronData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 ZA = 1;
  if (has_za()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->za(), target);
  }

  // required double AWR = 2;
  if (has_awr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->awr(), target);
  }

  // required double TEMPK = 3;
  if (has_tempk()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->tempk(), target);
  }

  // required .proto.ace.EnergyGrid energyMevGrid = 4;
  if (has_energymevgrid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->energymevgrid(), target);
  }

  // repeated .proto.ace.Reaction reactions = 5;
  for (int i = 0; i < this->reactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->reactions(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NeutronData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 ZA = 1;
    if (has_za()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->za());
    }

    // required double AWR = 2;
    if (has_awr()) {
      total_size += 1 + 8;
    }

    // required double TEMPK = 3;
    if (has_tempk()) {
      total_size += 1 + 8;
    }

    // required .proto.ace.EnergyGrid energyMevGrid = 4;
    if (has_energymevgrid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->energymevgrid());
    }

  }
  // repeated .proto.ace.Reaction reactions = 5;
  total_size += 1 * this->reactions_size();
  for (int i = 0; i < this->reactions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reactions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NeutronData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NeutronData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NeutronData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NeutronData::MergeFrom(const NeutronData& from) {
  GOOGLE_CHECK_NE(&from, this);
  reactions_.MergeFrom(from.reactions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_za()) {
      set_za(from.za());
    }
    if (from.has_awr()) {
      set_awr(from.awr());
    }
    if (from.has_tempk()) {
      set_tempk(from.tempk());
    }
    if (from.has_energymevgrid()) {
      mutable_energymevgrid()->::proto::ace::EnergyGrid::MergeFrom(from.energymevgrid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NeutronData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NeutronData::CopyFrom(const NeutronData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeutronData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_energymevgrid()) {
    if (!this->energymevgrid().IsInitialized()) return false;
  }
  for (int i = 0; i < reactions_size(); i++) {
    if (!this->reactions(i).IsInitialized()) return false;
  }
  return true;
}

void NeutronData::Swap(NeutronData* other) {
  if (other != this) {
    std::swap(za_, other->za_);
    std::swap(awr_, other->awr_);
    std::swap(tempk_, other->tempk_);
    std::swap(energymevgrid_, other->energymevgrid_);
    reactions_.Swap(&other->reactions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NeutronData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NeutronData_descriptor_;
  metadata.reflection = NeutronData_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ace
}  // namespace proto

// @@protoc_insertion_point(global_scope)
